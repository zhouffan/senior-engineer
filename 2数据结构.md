**数据**

- 数据项：一个数据元素可以由若干数据项组成。      （一个实体类的一个属性）
- 数据对象：有相同性质的数据元素的集合，是数据的子集。 （该实体类对象）
- 数据结构：是相互之间存在一种或多种**特定关系**的数据元素的集合。



**结构**

- 逻辑结构： 数据对象中数据元素之间的关系
  - 集合结构
  - 线性结构
  - 树形结构
  - 图形结构
- 物理结构：数据的逻辑结构在计算机中存储形式
  - 顺序存储 ：挨着排列
  - 链式存储 ：有地址指向下一个



# 1.线性表（顺序表/链表）

**线性表**：0个或者多个元素的有序列。

- 顺序表（arrayList等）：查找快， 增删慢(system.arraycopy)

  数组： 内存空间连续。  添加/删除 麻烦。

- 链表： 用任意的存储单元存储数据，内存地址是可以不连续的，只能循环遍历查找。

  插入时，插入值**先与后**一个产生链表关系，**再与前**一个修改链表关系

  删除时，删除值先断后一个，再断前一个 



- 单循表：

- 双向循表（LinkList）： 前驱/后继， **查找效率**比单链表快一倍



ArrayList与LinkedList区别： **顺序表与双链表**的区别



> **cpu缓存**：位于cpu与内存之间的临时存储器，解决cpu速度和内存速度的速度差异问题。
>
> **软件内存缓存**：预先将数据写入到容器（list/map/set）等数据存储单元中。
>
> **内存缓存淘汰机制**
>
> - FIFO：first in first out   先进先出
> - LFU：least frequently used  最不经常使用
> - LRU：least recently used   最近最少使用
>   - 新数据插入到链表头部。
>   - 当缓存命中（缓存数据被访问），数据移到头部。
>   - 当链表满了，将链表尾部数据丢弃。



# 2.队列

**队列**：**先进先出**表，运算受限的线性表。 队尾插入，队首取出。

生产者----> **缓存** （通常是通过队列实现）----> 消费者



循环队列：解决假溢出

假设循环队列容量N，并且预留一个空位置作为队列空/满/长度 判断标志

- 队空： front == rear
- 队满：(rear + 1)%N == front
- 队列元素个数：(rear - front + N) % N



**双端队列（Deque）**

- 具有队列和栈的性质的数据结构。
- 元素可以从两端插入和删除。

**优先级队列** （handle中的 MessageQueue：按照处理时间排队， PriorityQueue）

- 和通常的栈/队列意义，每个元素含有一个**优先级**。
- 首先处理优先级最高的；如果优先级相同，则按照插入顺序处理。



# 3.栈

**栈：**后进先出表， **栈顶**进行插入或者删除。

**存储结构**：

- 顺序结构：数组   (栈顶标识top)
- 链式结构：链表



> java中的stack是通过vector来实现的，设计被认为是不良的设计？
>
>  Stack --> Vector ---> AbstractList (数组)
>
> ===>继承后，会拥有父类的add到某个位置的方法，  这不符合栈的特性。



**栈的经典用法**： 逆波兰表达式法

计算机采用的 **后缀表达式**

10 + (5-2)*3 + 10/2    ==>   10 5 2 - 3 * + 10 2 / +

> 操作数栈：10 5 ......
>
> 操作符栈：+ - .....



- StackOverFlowError：栈溢出 （栈解决了程序的运行问题，解决如何执行/处理数据。负责**运算逻辑**）

  无限递归调用方法。     

  方法调用，进行入栈

- OutOfMemoryError：堆内存溢出 （堆解决 数据存储的问题，怎么存放。 负责**存储逻辑**）



# 4.树

特点：一个根， 一个或多个互不相交的子。（除了根节点，其他节点有且只有**一个父节点**，N个节点只有N-1条边）

- 结点的度：结点的子树个数。

- 树的度：树中所有节点最大的度。

- 叶节点：度为0的节点。



**二叉树**：

- 度为2的树（树中所有节点中最大的度）
- 子树有左右顺序之分

























